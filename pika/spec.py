# Autogenerated code, do not edit

import struct
import pika.specbase
import pika.table

PROTOCOL_VERSION = (0, 9)
PORT = 5672

FRAME_METHOD = 1
FRAME_HEADER = 2
FRAME_BODY = 3
FRAME_HEARTBEAT = 8
FRAME_MIN_SIZE = 4096
FRAME_END = 206
REPLY_SUCCESS = 200
CONTENT_TOO_LARGE = 311
NO_ROUTE = 312
NO_CONSUMERS = 313
ACCESS_REFUSED = 403
NOT_FOUND = 404
RESOURCE_LOCKED = 405
PRECONDITION_FAILED = 406
CONNECTION_FORCED = 320
INVALID_PATH = 402
FRAME_ERROR = 501
SYNTAX_ERROR = 502
COMMAND_INVALID = 503
CHANNEL_ERROR = 504
UNEXPECTED_FRAME = 505
RESOURCE_ERROR = 506
NOT_ALLOWED = 530
NOT_IMPLEMENTED = 540
INTERNAL_ERROR = 541

class Connection(pika.specbase.Class):
    INDEX = 0x000A ## 10
    NAME = 'Connection'

    class Start(pika.specbase.Method):
        INDEX = 0x000A000A ## 10, 10; 655370
        NAME = 'Connection.Start'
        def __init__(self, version_major = 0, version_minor = 8, server_properties = None, mechanisms = 'PLAIN', locales = 'en_US'):
            self.version_major = version_major
            self.version_minor = version_minor
            self.server_properties = server_properties
            self.mechanisms = mechanisms
            self.locales = locales

        def decode(self, encoded, offset = 0):
            self.version_major = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.version_minor = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            (self.server_properties, offset) = pika.table.decode_table(encoded, offset)
            length = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.mechanisms = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.locales = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', self.version_major))
            pieces.append(struct.pack('B', self.version_minor))
            pika.table.encode_table(pieces, self.server_properties)
            pieces.append(struct.pack('>I', len(self.mechanisms)))
            pieces.append(self.mechanisms)
            pieces.append(struct.pack('>I', len(self.locales)))
            pieces.append(self.locales)
            return pieces

    class StartOk(pika.specbase.Method):
        INDEX = 0x000A000B ## 10, 11; 655371
        NAME = 'Connection.StartOk'
        def __init__(self, client_properties = None, mechanism = 'PLAIN', response = None, locale = 'en_US'):
            self.client_properties = client_properties
            self.mechanism = mechanism
            self.response = response
            self.locale = locale

        def decode(self, encoded, offset = 0):
            (self.client_properties, offset) = pika.table.decode_table(encoded, offset)
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.mechanism = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.response = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.locale = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pika.table.encode_table(pieces, self.client_properties)
            pieces.append(struct.pack('B', len(self.mechanism)))
            pieces.append(self.mechanism)
            pieces.append(struct.pack('>I', len(self.response)))
            pieces.append(self.response)
            pieces.append(struct.pack('B', len(self.locale)))
            pieces.append(self.locale)
            return pieces

    class Secure(pika.specbase.Method):
        INDEX = 0x000A0014 ## 10, 20; 655380
        NAME = 'Connection.Secure'
        def __init__(self, challenge = None):
            self.challenge = challenge

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.challenge = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>I', len(self.challenge)))
            pieces.append(self.challenge)
            return pieces

    class SecureOk(pika.specbase.Method):
        INDEX = 0x000A0015 ## 10, 21; 655381
        NAME = 'Connection.SecureOk'
        def __init__(self, response = None):
            self.response = response

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.response = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>I', len(self.response)))
            pieces.append(self.response)
            return pieces

    class Tune(pika.specbase.Method):
        INDEX = 0x000A001E ## 10, 30; 655390
        NAME = 'Connection.Tune'
        def __init__(self, channel_max = 0, frame_max = 0, heartbeat = 0):
            self.channel_max = channel_max
            self.frame_max = frame_max
            self.heartbeat = heartbeat

        def decode(self, encoded, offset = 0):
            self.channel_max = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            self.frame_max = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.heartbeat = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.channel_max))
            pieces.append(struct.pack('>I', self.frame_max))
            pieces.append(struct.pack('>H', self.heartbeat))
            return pieces

    class TuneOk(pika.specbase.Method):
        INDEX = 0x000A001F ## 10, 31; 655391
        NAME = 'Connection.TuneOk'
        def __init__(self, channel_max = 0, frame_max = 0, heartbeat = 0):
            self.channel_max = channel_max
            self.frame_max = frame_max
            self.heartbeat = heartbeat

        def decode(self, encoded, offset = 0):
            self.channel_max = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            self.frame_max = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.heartbeat = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.channel_max))
            pieces.append(struct.pack('>I', self.frame_max))
            pieces.append(struct.pack('>H', self.heartbeat))
            return pieces

    class Open(pika.specbase.Method):
        INDEX = 0x000A0028 ## 10, 40; 655400
        NAME = 'Connection.Open'
        def __init__(self, virtual_host = '/', deprecated_capabilities = '', deprecated_insist = False):
            self.virtual_host = virtual_host
            self.deprecated_capabilities = deprecated_capabilities
            self.deprecated_insist = deprecated_insist

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.virtual_host = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.deprecated_capabilities = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.deprecated_insist = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.virtual_host)))
            pieces.append(self.virtual_host)
            pieces.append(struct.pack('B', len(self.deprecated_capabilities)))
            pieces.append(self.deprecated_capabilities)
            bit_buffer = 0;
            if self.deprecated_insist: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class OpenOk(pika.specbase.Method):
        INDEX = 0x000A0029 ## 10, 41; 655401
        NAME = 'Connection.OpenOk'
        def __init__(self, deprecated_known_hosts = ''):
            self.deprecated_known_hosts = deprecated_known_hosts

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.deprecated_known_hosts = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.deprecated_known_hosts)))
            pieces.append(self.deprecated_known_hosts)
            return pieces

    class Close(pika.specbase.Method):
        INDEX = 0x000A0032 ## 10, 50; 655410
        NAME = 'Connection.Close'
        def __init__(self, reply_code = None, reply_text = '', class_id = None, method_id = None):
            self.reply_code = reply_code
            self.reply_text = reply_text
            self.class_id = class_id
            self.method_id = method_id

        def decode(self, encoded, offset = 0):
            self.reply_code = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.reply_text = encoded[offset : offset + length]
            offset = offset + length
            self.class_id = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            self.method_id = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.reply_code))
            pieces.append(struct.pack('B', len(self.reply_text)))
            pieces.append(self.reply_text)
            pieces.append(struct.pack('>H', self.class_id))
            pieces.append(struct.pack('>H', self.method_id))
            return pieces

    class CloseOk(pika.specbase.Method):
        INDEX = 0x000A0033 ## 10, 51; 655411
        NAME = 'Connection.CloseOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

class Channel(pika.specbase.Class):
    INDEX = 0x0014 ## 20
    NAME = 'Channel'

    class Open(pika.specbase.Method):
        INDEX = 0x0014000A ## 20, 10; 1310730
        NAME = 'Channel.Open'
        def __init__(self, deprecated_out_of_band = ''):
            self.deprecated_out_of_band = deprecated_out_of_band

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.deprecated_out_of_band = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.deprecated_out_of_band)))
            pieces.append(self.deprecated_out_of_band)
            return pieces

    class OpenOk(pika.specbase.Method):
        INDEX = 0x0014000B ## 20, 11; 1310731
        NAME = 'Channel.OpenOk'
        def __init__(self, deprecated_channel_id = ''):
            self.deprecated_channel_id = deprecated_channel_id

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.deprecated_channel_id = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>I', len(self.deprecated_channel_id)))
            pieces.append(self.deprecated_channel_id)
            return pieces

    class Flow(pika.specbase.Method):
        INDEX = 0x00140014 ## 20, 20; 1310740
        NAME = 'Channel.Flow'
        def __init__(self, active = None):
            self.active = active

        def decode(self, encoded, offset = 0):
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.active = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            bit_buffer = 0;
            if self.active: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class FlowOk(pika.specbase.Method):
        INDEX = 0x00140015 ## 20, 21; 1310741
        NAME = 'Channel.FlowOk'
        def __init__(self, active = None):
            self.active = active

        def decode(self, encoded, offset = 0):
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.active = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            bit_buffer = 0;
            if self.active: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class Close(pika.specbase.Method):
        INDEX = 0x00140028 ## 20, 40; 1310760
        NAME = 'Channel.Close'
        def __init__(self, reply_code = None, reply_text = '', class_id = None, method_id = None):
            self.reply_code = reply_code
            self.reply_text = reply_text
            self.class_id = class_id
            self.method_id = method_id

        def decode(self, encoded, offset = 0):
            self.reply_code = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.reply_text = encoded[offset : offset + length]
            offset = offset + length
            self.class_id = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            self.method_id = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.reply_code))
            pieces.append(struct.pack('B', len(self.reply_text)))
            pieces.append(self.reply_text)
            pieces.append(struct.pack('>H', self.class_id))
            pieces.append(struct.pack('>H', self.method_id))
            return pieces

    class CloseOk(pika.specbase.Method):
        INDEX = 0x00140029 ## 20, 41; 1310761
        NAME = 'Channel.CloseOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

class Exchange(pika.specbase.Class):
    INDEX = 0x0028 ## 40
    NAME = 'Exchange'

    class Declare(pika.specbase.Method):
        INDEX = 0x0028000A ## 40, 10; 2621450
        NAME = 'Exchange.Declare'
        def __init__(self, deprecated_ticket = 1, exchange = None, type = 'direct', passive = False, durable = False, deprecated_auto_delete = False, deprecated_internal = False, nowait = False, arguments = {}):
            self.deprecated_ticket = deprecated_ticket
            self.exchange = exchange
            self.type = type
            self.passive = passive
            self.durable = durable
            self.deprecated_auto_delete = deprecated_auto_delete
            self.deprecated_internal = deprecated_internal
            self.nowait = nowait
            self.arguments = arguments

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.type = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.passive = (bit_buffer & (1 << 0)) != 0
            self.durable = (bit_buffer & (1 << 1)) != 0
            self.deprecated_auto_delete = (bit_buffer & (1 << 2)) != 0
            self.deprecated_internal = (bit_buffer & (1 << 3)) != 0
            self.nowait = (bit_buffer & (1 << 4)) != 0
            (self.arguments, offset) = pika.table.decode_table(encoded, offset)
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            pieces.append(struct.pack('B', len(self.type)))
            pieces.append(self.type)
            bit_buffer = 0;
            if self.passive: bit_buffer = bit_buffer | (1 << 0)
            if self.durable: bit_buffer = bit_buffer | (1 << 1)
            if self.deprecated_auto_delete: bit_buffer = bit_buffer | (1 << 2)
            if self.deprecated_internal: bit_buffer = bit_buffer | (1 << 3)
            if self.nowait: bit_buffer = bit_buffer | (1 << 4)
            pieces.append(struct.pack('B', bit_buffer))
            pika.table.encode_table(pieces, self.arguments)
            return pieces

    class DeclareOk(pika.specbase.Method):
        INDEX = 0x0028000B ## 40, 11; 2621451
        NAME = 'Exchange.DeclareOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class Delete(pika.specbase.Method):
        INDEX = 0x00280014 ## 40, 20; 2621460
        NAME = 'Exchange.Delete'
        def __init__(self, deprecated_ticket = 1, exchange = None, if_unused = False, nowait = False):
            self.deprecated_ticket = deprecated_ticket
            self.exchange = exchange
            self.if_unused = if_unused
            self.nowait = nowait

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.if_unused = (bit_buffer & (1 << 0)) != 0
            self.nowait = (bit_buffer & (1 << 1)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            bit_buffer = 0;
            if self.if_unused: bit_buffer = bit_buffer | (1 << 0)
            if self.nowait: bit_buffer = bit_buffer | (1 << 1)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class DeleteOk(pika.specbase.Method):
        INDEX = 0x00280015 ## 40, 21; 2621461
        NAME = 'Exchange.DeleteOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

class Queue(pika.specbase.Class):
    INDEX = 0x0032 ## 50
    NAME = 'Queue'

    class Declare(pika.specbase.Method):
        INDEX = 0x0032000A ## 50, 10; 3276810
        NAME = 'Queue.Declare'
        def __init__(self, deprecated_ticket = 1, queue = '', passive = False, durable = False, exclusive = False, auto_delete = False, nowait = False, arguments = {}):
            self.deprecated_ticket = deprecated_ticket
            self.queue = queue
            self.passive = passive
            self.durable = durable
            self.exclusive = exclusive
            self.auto_delete = auto_delete
            self.nowait = nowait
            self.arguments = arguments

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.passive = (bit_buffer & (1 << 0)) != 0
            self.durable = (bit_buffer & (1 << 1)) != 0
            self.exclusive = (bit_buffer & (1 << 2)) != 0
            self.auto_delete = (bit_buffer & (1 << 3)) != 0
            self.nowait = (bit_buffer & (1 << 4)) != 0
            (self.arguments, offset) = pika.table.decode_table(encoded, offset)
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            bit_buffer = 0;
            if self.passive: bit_buffer = bit_buffer | (1 << 0)
            if self.durable: bit_buffer = bit_buffer | (1 << 1)
            if self.exclusive: bit_buffer = bit_buffer | (1 << 2)
            if self.auto_delete: bit_buffer = bit_buffer | (1 << 3)
            if self.nowait: bit_buffer = bit_buffer | (1 << 4)
            pieces.append(struct.pack('B', bit_buffer))
            pika.table.encode_table(pieces, self.arguments)
            return pieces

    class DeclareOk(pika.specbase.Method):
        INDEX = 0x0032000B ## 50, 11; 3276811
        NAME = 'Queue.DeclareOk'
        def __init__(self, queue = None, message_count = None, consumer_count = None):
            self.queue = queue
            self.message_count = message_count
            self.consumer_count = consumer_count

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            self.message_count = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.consumer_count = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            pieces.append(struct.pack('>I', self.message_count))
            pieces.append(struct.pack('>I', self.consumer_count))
            return pieces

    class Bind(pika.specbase.Method):
        INDEX = 0x00320014 ## 50, 20; 3276820
        NAME = 'Queue.Bind'
        def __init__(self, deprecated_ticket = 1, queue = None, exchange = None, routing_key = None, nowait = False, arguments = {}):
            self.deprecated_ticket = deprecated_ticket
            self.queue = queue
            self.exchange = exchange
            self.routing_key = routing_key
            self.nowait = nowait
            self.arguments = arguments

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.routing_key = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.nowait = (bit_buffer & (1 << 0)) != 0
            (self.arguments, offset) = pika.table.decode_table(encoded, offset)
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            pieces.append(struct.pack('B', len(self.routing_key)))
            pieces.append(self.routing_key)
            bit_buffer = 0;
            if self.nowait: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            pika.table.encode_table(pieces, self.arguments)
            return pieces

    class BindOk(pika.specbase.Method):
        INDEX = 0x00320015 ## 50, 21; 3276821
        NAME = 'Queue.BindOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class Purge(pika.specbase.Method):
        INDEX = 0x0032001E ## 50, 30; 3276830
        NAME = 'Queue.Purge'
        def __init__(self, deprecated_ticket = 1, queue = None, nowait = False):
            self.deprecated_ticket = deprecated_ticket
            self.queue = queue
            self.nowait = nowait

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.nowait = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            bit_buffer = 0;
            if self.nowait: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class PurgeOk(pika.specbase.Method):
        INDEX = 0x0032001F ## 50, 31; 3276831
        NAME = 'Queue.PurgeOk'
        def __init__(self, message_count = None):
            self.message_count = message_count

        def decode(self, encoded, offset = 0):
            self.message_count = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>I', self.message_count))
            return pieces

    class Delete(pika.specbase.Method):
        INDEX = 0x00320028 ## 50, 40; 3276840
        NAME = 'Queue.Delete'
        def __init__(self, deprecated_ticket = 1, queue = None, if_unused = False, if_empty = False, nowait = False):
            self.deprecated_ticket = deprecated_ticket
            self.queue = queue
            self.if_unused = if_unused
            self.if_empty = if_empty
            self.nowait = nowait

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.if_unused = (bit_buffer & (1 << 0)) != 0
            self.if_empty = (bit_buffer & (1 << 1)) != 0
            self.nowait = (bit_buffer & (1 << 2)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            bit_buffer = 0;
            if self.if_unused: bit_buffer = bit_buffer | (1 << 0)
            if self.if_empty: bit_buffer = bit_buffer | (1 << 1)
            if self.nowait: bit_buffer = bit_buffer | (1 << 2)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class DeleteOk(pika.specbase.Method):
        INDEX = 0x00320029 ## 50, 41; 3276841
        NAME = 'Queue.DeleteOk'
        def __init__(self, message_count = None):
            self.message_count = message_count

        def decode(self, encoded, offset = 0):
            self.message_count = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>I', self.message_count))
            return pieces

    class Unbind(pika.specbase.Method):
        INDEX = 0x00320032 ## 50, 50; 3276850
        NAME = 'Queue.Unbind'
        def __init__(self, deprecated_ticket = 1, queue = None, exchange = None, routing_key = None, arguments = None):
            self.deprecated_ticket = deprecated_ticket
            self.queue = queue
            self.exchange = exchange
            self.routing_key = routing_key
            self.arguments = arguments

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.routing_key = encoded[offset : offset + length]
            offset = offset + length
            (self.arguments, offset) = pika.table.decode_table(encoded, offset)
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            pieces.append(struct.pack('B', len(self.routing_key)))
            pieces.append(self.routing_key)
            pika.table.encode_table(pieces, self.arguments)
            return pieces

    class UnbindOk(pika.specbase.Method):
        INDEX = 0x00320033 ## 50, 51; 3276851
        NAME = 'Queue.UnbindOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

class Basic(pika.specbase.Class):
    INDEX = 0x003C ## 60
    NAME = 'Basic'

    class Qos(pika.specbase.Method):
        INDEX = 0x003C000A ## 60, 10; 3932170
        NAME = 'Basic.Qos'
        def __init__(self, prefetch_size = 0, prefetch_count = 0, global_ = False):
            self.prefetch_size = prefetch_size
            self.prefetch_count = prefetch_count
            self.global_ = global_

        def decode(self, encoded, offset = 0):
            self.prefetch_size = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            self.prefetch_count = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.global_ = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>I', self.prefetch_size))
            pieces.append(struct.pack('>H', self.prefetch_count))
            bit_buffer = 0;
            if self.global_: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class QosOk(pika.specbase.Method):
        INDEX = 0x003C000B ## 60, 11; 3932171
        NAME = 'Basic.QosOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class Consume(pika.specbase.Method):
        INDEX = 0x003C0014 ## 60, 20; 3932180
        NAME = 'Basic.Consume'
        def __init__(self, deprecated_ticket = 1, queue = None, consumer_tag = None, no_local = False, no_ack = False, exclusive = False, nowait = False, filter = {}):
            self.deprecated_ticket = deprecated_ticket
            self.queue = queue
            self.consumer_tag = consumer_tag
            self.no_local = no_local
            self.no_ack = no_ack
            self.exclusive = exclusive
            self.nowait = nowait
            self.filter = filter

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.consumer_tag = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.no_local = (bit_buffer & (1 << 0)) != 0
            self.no_ack = (bit_buffer & (1 << 1)) != 0
            self.exclusive = (bit_buffer & (1 << 2)) != 0
            self.nowait = (bit_buffer & (1 << 3)) != 0
            (self.filter, offset) = pika.table.decode_table(encoded, offset)
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            pieces.append(struct.pack('B', len(self.consumer_tag)))
            pieces.append(self.consumer_tag)
            bit_buffer = 0;
            if self.no_local: bit_buffer = bit_buffer | (1 << 0)
            if self.no_ack: bit_buffer = bit_buffer | (1 << 1)
            if self.exclusive: bit_buffer = bit_buffer | (1 << 2)
            if self.nowait: bit_buffer = bit_buffer | (1 << 3)
            pieces.append(struct.pack('B', bit_buffer))
            pika.table.encode_table(pieces, self.filter)
            return pieces

    class ConsumeOk(pika.specbase.Method):
        INDEX = 0x003C0015 ## 60, 21; 3932181
        NAME = 'Basic.ConsumeOk'
        def __init__(self, consumer_tag = None):
            self.consumer_tag = consumer_tag

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.consumer_tag = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.consumer_tag)))
            pieces.append(self.consumer_tag)
            return pieces

    class Cancel(pika.specbase.Method):
        INDEX = 0x003C001E ## 60, 30; 3932190
        NAME = 'Basic.Cancel'
        def __init__(self, consumer_tag = None, nowait = False):
            self.consumer_tag = consumer_tag
            self.nowait = nowait

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.consumer_tag = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.nowait = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.consumer_tag)))
            pieces.append(self.consumer_tag)
            bit_buffer = 0;
            if self.nowait: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class CancelOk(pika.specbase.Method):
        INDEX = 0x003C001F ## 60, 31; 3932191
        NAME = 'Basic.CancelOk'
        def __init__(self, consumer_tag = None):
            self.consumer_tag = consumer_tag

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.consumer_tag = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.consumer_tag)))
            pieces.append(self.consumer_tag)
            return pieces

    class Publish(pika.specbase.Method):
        INDEX = 0x003C0028 ## 60, 40; 3932200
        NAME = 'Basic.Publish'
        def __init__(self, deprecated_ticket = 1, exchange = '', routing_key = None, mandatory = False, immediate = False):
            self.deprecated_ticket = deprecated_ticket
            self.exchange = exchange
            self.routing_key = routing_key
            self.mandatory = mandatory
            self.immediate = immediate

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.routing_key = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.mandatory = (bit_buffer & (1 << 0)) != 0
            self.immediate = (bit_buffer & (1 << 1)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            pieces.append(struct.pack('B', len(self.routing_key)))
            pieces.append(self.routing_key)
            bit_buffer = 0;
            if self.mandatory: bit_buffer = bit_buffer | (1 << 0)
            if self.immediate: bit_buffer = bit_buffer | (1 << 1)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class Return(pika.specbase.Method):
        INDEX = 0x003C0032 ## 60, 50; 3932210
        NAME = 'Basic.Return'
        def __init__(self, reply_code = None, reply_text = '', exchange = None, routing_key = None):
            self.reply_code = reply_code
            self.reply_text = reply_text
            self.exchange = exchange
            self.routing_key = routing_key

        def decode(self, encoded, offset = 0):
            self.reply_code = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.reply_text = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.routing_key = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.reply_code))
            pieces.append(struct.pack('B', len(self.reply_text)))
            pieces.append(self.reply_text)
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            pieces.append(struct.pack('B', len(self.routing_key)))
            pieces.append(self.routing_key)
            return pieces

    class Deliver(pika.specbase.Method):
        INDEX = 0x003C003C ## 60, 60; 3932220
        NAME = 'Basic.Deliver'
        def __init__(self, consumer_tag = None, delivery_tag = None, redelivered = False, exchange = None, routing_key = None):
            self.consumer_tag = consumer_tag
            self.delivery_tag = delivery_tag
            self.redelivered = redelivered
            self.exchange = exchange
            self.routing_key = routing_key

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.consumer_tag = encoded[offset : offset + length]
            offset = offset + length
            self.delivery_tag = struct.unpack_from('>Q', encoded, offset)[0]
            offset = offset + 8
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.redelivered = (bit_buffer & (1 << 0)) != 0
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.routing_key = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.consumer_tag)))
            pieces.append(self.consumer_tag)
            pieces.append(struct.pack('>Q', self.delivery_tag))
            bit_buffer = 0;
            if self.redelivered: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            pieces.append(struct.pack('B', len(self.routing_key)))
            pieces.append(self.routing_key)
            return pieces

    class Get(pika.specbase.Method):
        INDEX = 0x003C0046 ## 60, 70; 3932230
        NAME = 'Basic.Get'
        def __init__(self, deprecated_ticket = 1, queue = None, no_ack = False):
            self.deprecated_ticket = deprecated_ticket
            self.queue = queue
            self.no_ack = no_ack

        def decode(self, encoded, offset = 0):
            self.deprecated_ticket = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.queue = encoded[offset : offset + length]
            offset = offset + length
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.no_ack = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>H', self.deprecated_ticket))
            pieces.append(struct.pack('B', len(self.queue)))
            pieces.append(self.queue)
            bit_buffer = 0;
            if self.no_ack: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class GetOk(pika.specbase.Method):
        INDEX = 0x003C0047 ## 60, 71; 3932231
        NAME = 'Basic.GetOk'
        def __init__(self, delivery_tag = None, redelivered = False, exchange = None, routing_key = None, message_count = None):
            self.delivery_tag = delivery_tag
            self.redelivered = redelivered
            self.exchange = exchange
            self.routing_key = routing_key
            self.message_count = message_count

        def decode(self, encoded, offset = 0):
            self.delivery_tag = struct.unpack_from('>Q', encoded, offset)[0]
            offset = offset + 8
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.redelivered = (bit_buffer & (1 << 0)) != 0
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.exchange = encoded[offset : offset + length]
            offset = offset + length
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.routing_key = encoded[offset : offset + length]
            offset = offset + length
            self.message_count = struct.unpack_from('>I', encoded, offset)[0]
            offset = offset + 4
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>Q', self.delivery_tag))
            bit_buffer = 0;
            if self.redelivered: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            pieces.append(struct.pack('B', len(self.exchange)))
            pieces.append(self.exchange)
            pieces.append(struct.pack('B', len(self.routing_key)))
            pieces.append(self.routing_key)
            pieces.append(struct.pack('>I', self.message_count))
            return pieces

    class GetEmpty(pika.specbase.Method):
        INDEX = 0x003C0048 ## 60, 72; 3932232
        NAME = 'Basic.GetEmpty'
        def __init__(self, deprecated_cluster_id = ''):
            self.deprecated_cluster_id = deprecated_cluster_id

        def decode(self, encoded, offset = 0):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.deprecated_cluster_id = encoded[offset : offset + length]
            offset = offset + length
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('B', len(self.deprecated_cluster_id)))
            pieces.append(self.deprecated_cluster_id)
            return pieces

    class Ack(pika.specbase.Method):
        INDEX = 0x003C0050 ## 60, 80; 3932240
        NAME = 'Basic.Ack'
        def __init__(self, delivery_tag = 0, multiple = True):
            self.delivery_tag = delivery_tag
            self.multiple = multiple

        def decode(self, encoded, offset = 0):
            self.delivery_tag = struct.unpack_from('>Q', encoded, offset)[0]
            offset = offset + 8
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.multiple = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>Q', self.delivery_tag))
            bit_buffer = 0;
            if self.multiple: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class Reject(pika.specbase.Method):
        INDEX = 0x003C005A ## 60, 90; 3932250
        NAME = 'Basic.Reject'
        def __init__(self, delivery_tag = None, requeue = True):
            self.delivery_tag = delivery_tag
            self.requeue = requeue

        def decode(self, encoded, offset = 0):
            self.delivery_tag = struct.unpack_from('>Q', encoded, offset)[0]
            offset = offset + 8
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.requeue = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            pieces.append(struct.pack('>Q', self.delivery_tag))
            bit_buffer = 0;
            if self.requeue: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class RecoverAsync(pika.specbase.Method):
        INDEX = 0x003C0064 ## 60, 100; 3932260
        NAME = 'Basic.RecoverAsync'
        def __init__(self, requeue = False):
            self.requeue = requeue

        def decode(self, encoded, offset = 0):
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.requeue = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            bit_buffer = 0;
            if self.requeue: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class Recover(pika.specbase.Method):
        INDEX = 0x003C006E ## 60, 110; 3932270
        NAME = 'Basic.Recover'
        def __init__(self, requeue = False):
            self.requeue = requeue

        def decode(self, encoded, offset = 0):
            bit_buffer = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.requeue = (bit_buffer & (1 << 0)) != 0
            return self

        def encode(self):
            pieces = []
            bit_buffer = 0;
            if self.requeue: bit_buffer = bit_buffer | (1 << 0)
            pieces.append(struct.pack('B', bit_buffer))
            return pieces

    class RecoverOk(pika.specbase.Method):
        INDEX = 0x003C006F ## 60, 111; 3932271
        NAME = 'Basic.RecoverOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

class Tx(pika.specbase.Class):
    INDEX = 0x005A ## 90
    NAME = 'Tx'

    class Select(pika.specbase.Method):
        INDEX = 0x005A000A ## 90, 10; 5898250
        NAME = 'Tx.Select'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class SelectOk(pika.specbase.Method):
        INDEX = 0x005A000B ## 90, 11; 5898251
        NAME = 'Tx.SelectOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class Commit(pika.specbase.Method):
        INDEX = 0x005A0014 ## 90, 20; 5898260
        NAME = 'Tx.Commit'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class CommitOk(pika.specbase.Method):
        INDEX = 0x005A0015 ## 90, 21; 5898261
        NAME = 'Tx.CommitOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class Rollback(pika.specbase.Method):
        INDEX = 0x005A001E ## 90, 30; 5898270
        NAME = 'Tx.Rollback'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

    class RollbackOk(pika.specbase.Method):
        INDEX = 0x005A001F ## 90, 31; 5898271
        NAME = 'Tx.RollbackOk'
        def __init__(self):
            pass
        def decode(self, encoded, offset = 0):
            return self

        def encode(self):
            pieces = []
            return pieces

class BasicProperties(pika.specbase.Properties):
    CLASS = Basic
    INDEX = 0x003C ## 60
    NAME = 'BasicProperties'
    FLAG_CONTENT_TYPE = (1 << 15)
    FLAG_CONTENT_ENCODING = (1 << 14)
    FLAG_HEADERS = (1 << 13)
    FLAG_DELIVERY_MODE = (1 << 12)
    FLAG_PRIORITY = (1 << 11)
    FLAG_CORRELATION_ID = (1 << 10)
    FLAG_REPLY_TO = (1 << 9)
    FLAG_EXPIRATION = (1 << 8)
    FLAG_MESSAGE_ID = (1 << 7)
    FLAG_TIMESTAMP = (1 << 6)
    FLAG_TYPE = (1 << 5)
    FLAG_USER_ID = (1 << 4)
    FLAG_APP_ID = (1 << 3)
    FLAG_DEPRECATED_CLUSTER_ID = (1 << 2)

    def __init__(self, content_type = None, content_encoding = None, headers = None, delivery_mode = None, priority = None, correlation_id = None, reply_to = None, expiration = None, message_id = None, timestamp = None, type = None, user_id = None, app_id = None, deprecated_cluster_id = None):
        self.content_type = content_type
        self.content_encoding = content_encoding
        self.headers = headers
        self.delivery_mode = delivery_mode
        self.priority = priority
        self.correlation_id = correlation_id
        self.reply_to = reply_to
        self.expiration = expiration
        self.message_id = message_id
        self.timestamp = timestamp
        self.type = type
        self.user_id = user_id
        self.app_id = app_id
        self.deprecated_cluster_id = deprecated_cluster_id

    def decode(self, encoded, offset = 0):
        flags = 0
        flagword_index = 0
        while True:
            partial_flags = struct.unpack_from('>H', encoded, offset)[0]
            offset = offset + 2
            flags = flags | (partial_flags << (flagword_index * 16))
            if (partial_flags & 1) == 0: break
            flagword_index = flagword_index + 1
        if (flags & BasicProperties.FLAG_CONTENT_TYPE):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.content_type = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.content_type = None
        if (flags & BasicProperties.FLAG_CONTENT_ENCODING):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.content_encoding = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.content_encoding = None
        if (flags & BasicProperties.FLAG_HEADERS):
            (self.headers, offset) = pika.table.decode_table(encoded, offset)
        else:
            self.headers = None
        if (flags & BasicProperties.FLAG_DELIVERY_MODE):
            self.delivery_mode = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
        else:
            self.delivery_mode = None
        if (flags & BasicProperties.FLAG_PRIORITY):
            self.priority = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
        else:
            self.priority = None
        if (flags & BasicProperties.FLAG_CORRELATION_ID):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.correlation_id = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.correlation_id = None
        if (flags & BasicProperties.FLAG_REPLY_TO):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.reply_to = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.reply_to = None
        if (flags & BasicProperties.FLAG_EXPIRATION):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.expiration = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.expiration = None
        if (flags & BasicProperties.FLAG_MESSAGE_ID):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.message_id = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.message_id = None
        if (flags & BasicProperties.FLAG_TIMESTAMP):
            self.timestamp = struct.unpack_from('>Q', encoded, offset)[0]
            offset = offset + 8
        else:
            self.timestamp = None
        if (flags & BasicProperties.FLAG_TYPE):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.type = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.type = None
        if (flags & BasicProperties.FLAG_USER_ID):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.user_id = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.user_id = None
        if (flags & BasicProperties.FLAG_APP_ID):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.app_id = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.app_id = None
        if (flags & BasicProperties.FLAG_DEPRECATED_CLUSTER_ID):
            length = struct.unpack_from('B', encoded, offset)[0]
            offset = offset + 1
            self.deprecated_cluster_id = encoded[offset : offset + length]
            offset = offset + length
        else:
            self.deprecated_cluster_id = None
        return self

    def encode(self):
        pieces = []
        flags = 0
        if self.content_type is not None:
            flags = flags | BasicProperties.FLAG_CONTENT_TYPE
            pieces.append(struct.pack('B', len(self.content_type)))
            pieces.append(self.content_type)
        if self.content_encoding is not None:
            flags = flags | BasicProperties.FLAG_CONTENT_ENCODING
            pieces.append(struct.pack('B', len(self.content_encoding)))
            pieces.append(self.content_encoding)
        if self.headers is not None:
            flags = flags | BasicProperties.FLAG_HEADERS
            pika.table.encode_table(pieces, self.headers)
        if self.delivery_mode is not None:
            flags = flags | BasicProperties.FLAG_DELIVERY_MODE
            pieces.append(struct.pack('B', self.delivery_mode))
        if self.priority is not None:
            flags = flags | BasicProperties.FLAG_PRIORITY
            pieces.append(struct.pack('B', self.priority))
        if self.correlation_id is not None:
            flags = flags | BasicProperties.FLAG_CORRELATION_ID
            pieces.append(struct.pack('B', len(self.correlation_id)))
            pieces.append(self.correlation_id)
        if self.reply_to is not None:
            flags = flags | BasicProperties.FLAG_REPLY_TO
            pieces.append(struct.pack('B', len(self.reply_to)))
            pieces.append(self.reply_to)
        if self.expiration is not None:
            flags = flags | BasicProperties.FLAG_EXPIRATION
            pieces.append(struct.pack('B', len(self.expiration)))
            pieces.append(self.expiration)
        if self.message_id is not None:
            flags = flags | BasicProperties.FLAG_MESSAGE_ID
            pieces.append(struct.pack('B', len(self.message_id)))
            pieces.append(self.message_id)
        if self.timestamp is not None:
            flags = flags | BasicProperties.FLAG_TIMESTAMP
            pieces.append(struct.pack('>Q', self.timestamp))
        if self.type is not None:
            flags = flags | BasicProperties.FLAG_TYPE
            pieces.append(struct.pack('B', len(self.type)))
            pieces.append(self.type)
        if self.user_id is not None:
            flags = flags | BasicProperties.FLAG_USER_ID
            pieces.append(struct.pack('B', len(self.user_id)))
            pieces.append(self.user_id)
        if self.app_id is not None:
            flags = flags | BasicProperties.FLAG_APP_ID
            pieces.append(struct.pack('B', len(self.app_id)))
            pieces.append(self.app_id)
        if self.deprecated_cluster_id is not None:
            flags = flags | BasicProperties.FLAG_DEPRECATED_CLUSTER_ID
            pieces.append(struct.pack('B', len(self.deprecated_cluster_id)))
            pieces.append(self.deprecated_cluster_id)
        flag_pieces = []
        while True:
            remainder = flags >> 16
            partial_flags = flags & 0xFFFE
            if remainder != 0: partial_flags = partial_flags | 1
            flag_pieces.append(struct.pack('>H', partial_flags))
            flags = remainder
            if flags == 0: break
        return flag_pieces + pieces

methods = {
    0x000A000A: Connection.Start,
    0x000A000B: Connection.StartOk,
    0x000A0014: Connection.Secure,
    0x000A0015: Connection.SecureOk,
    0x000A001E: Connection.Tune,
    0x000A001F: Connection.TuneOk,
    0x000A0028: Connection.Open,
    0x000A0029: Connection.OpenOk,
    0x000A0032: Connection.Close,
    0x000A0033: Connection.CloseOk,
    0x0014000A: Channel.Open,
    0x0014000B: Channel.OpenOk,
    0x00140014: Channel.Flow,
    0x00140015: Channel.FlowOk,
    0x00140028: Channel.Close,
    0x00140029: Channel.CloseOk,
    0x0028000A: Exchange.Declare,
    0x0028000B: Exchange.DeclareOk,
    0x00280014: Exchange.Delete,
    0x00280015: Exchange.DeleteOk,
    0x0032000A: Queue.Declare,
    0x0032000B: Queue.DeclareOk,
    0x00320014: Queue.Bind,
    0x00320015: Queue.BindOk,
    0x0032001E: Queue.Purge,
    0x0032001F: Queue.PurgeOk,
    0x00320028: Queue.Delete,
    0x00320029: Queue.DeleteOk,
    0x00320032: Queue.Unbind,
    0x00320033: Queue.UnbindOk,
    0x003C000A: Basic.Qos,
    0x003C000B: Basic.QosOk,
    0x003C0014: Basic.Consume,
    0x003C0015: Basic.ConsumeOk,
    0x003C001E: Basic.Cancel,
    0x003C001F: Basic.CancelOk,
    0x003C0028: Basic.Publish,
    0x003C0032: Basic.Return,
    0x003C003C: Basic.Deliver,
    0x003C0046: Basic.Get,
    0x003C0047: Basic.GetOk,
    0x003C0048: Basic.GetEmpty,
    0x003C0050: Basic.Ack,
    0x003C005A: Basic.Reject,
    0x003C0064: Basic.RecoverAsync,
    0x003C006E: Basic.Recover,
    0x003C006F: Basic.RecoverOk,
    0x005A000A: Tx.Select,
    0x005A000B: Tx.SelectOk,
    0x005A0014: Tx.Commit,
    0x005A0015: Tx.CommitOk,
    0x005A001E: Tx.Rollback,
    0x005A001F: Tx.RollbackOk
}

props = {
    0x003C: BasicProperties
}

def has_content(methodNumber):
    if methodNumber == Basic.Publish.INDEX: return True
    if methodNumber == Basic.Return.INDEX: return True
    if methodNumber == Basic.Deliver.INDEX: return True
    if methodNumber == Basic.GetOk.INDEX: return True
    return False

class DriverMixin:
    def exchange_declare(self, deprecated_ticket = 1, exchange = None, type = 'direct', passive = False, durable = False, deprecated_auto_delete = False, deprecated_internal = False, nowait = False, arguments = {}):
        return self.handler._rpc(Exchange.Declare(deprecated_ticket = deprecated_ticket, exchange = exchange, type = type, passive = passive, durable = durable, deprecated_auto_delete = deprecated_auto_delete, deprecated_internal = deprecated_internal, nowait = nowait, arguments = arguments),
                                 [Exchange.DeclareOk])

    def exchange_delete(self, deprecated_ticket = 1, exchange = None, if_unused = False, nowait = False):
        return self.handler._rpc(Exchange.Delete(deprecated_ticket = deprecated_ticket, exchange = exchange, if_unused = if_unused, nowait = nowait),
                                 [Exchange.DeleteOk])

    def queue_declare(self, deprecated_ticket = 1, queue = '', passive = False, durable = False, exclusive = False, auto_delete = False, nowait = False, arguments = {}):
        return self.handler._rpc(Queue.Declare(deprecated_ticket = deprecated_ticket, queue = queue, passive = passive, durable = durable, exclusive = exclusive, auto_delete = auto_delete, nowait = nowait, arguments = arguments),
                                 [Queue.DeclareOk])

    def queue_bind(self, deprecated_ticket = 1, queue = None, exchange = None, routing_key = None, nowait = False, arguments = {}):
        return self.handler._rpc(Queue.Bind(deprecated_ticket = deprecated_ticket, queue = queue, exchange = exchange, routing_key = routing_key, nowait = nowait, arguments = arguments),
                                 [Queue.BindOk])

    def queue_purge(self, deprecated_ticket = 1, queue = None, nowait = False):
        return self.handler._rpc(Queue.Purge(deprecated_ticket = deprecated_ticket, queue = queue, nowait = nowait),
                                 [Queue.PurgeOk])

    def queue_delete(self, deprecated_ticket = 1, queue = None, if_unused = False, if_empty = False, nowait = False):
        return self.handler._rpc(Queue.Delete(deprecated_ticket = deprecated_ticket, queue = queue, if_unused = if_unused, if_empty = if_empty, nowait = nowait),
                                 [Queue.DeleteOk])

    def queue_unbind(self, deprecated_ticket = 1, queue = None, exchange = None, routing_key = None, arguments = None):
        return self.handler._rpc(Queue.Unbind(deprecated_ticket = deprecated_ticket, queue = queue, exchange = exchange, routing_key = routing_key, arguments = arguments),
                                 [Queue.UnbindOk])

    def basic_qos(self, prefetch_size = 0, prefetch_count = 0, global_ = False):
        return self.handler._rpc(Basic.Qos(prefetch_size = prefetch_size, prefetch_count = prefetch_count, global_ = global_),
                                 [Basic.QosOk])

    def basic_get(self, deprecated_ticket = 1, queue = None, no_ack = False):
        return self.handler._rpc(Basic.Get(deprecated_ticket = deprecated_ticket, queue = queue, no_ack = no_ack),
                                 [Basic.GetOk, Basic.GetEmpty])

    def basic_ack(self, delivery_tag = 0, multiple = True):
        return self.handler._rpc(Basic.Ack(delivery_tag = delivery_tag, multiple = multiple),
                                 [])

    def basic_reject(self, delivery_tag = None, requeue = True):
        return self.handler._rpc(Basic.Reject(delivery_tag = delivery_tag, requeue = requeue),
                                 [])

    def basic_recover(self, requeue = False):
        return self.handler._rpc(Basic.Recover(requeue = requeue),
                                 [])

    def tx_select(self):
        return self.handler._rpc(Tx.Select(),
                                 [Tx.SelectOk])

    def tx_commit(self):
        return self.handler._rpc(Tx.Commit(),
                                 [Tx.CommitOk])

    def tx_rollback(self):
        return self.handler._rpc(Tx.Rollback(),
                                 [Tx.RollbackOk])

